{
  "version": 3,
  "sources": ["src/preset.ts", "src/radix-colors.ts", "src/utils.ts", "src/semantic-tokens.ts", "src/types.ts"],
  "sourcesContent": [
    "import { definePreset } from \"@pandacss/dev\";\nimport type { Preset, Conditions } from \"@pandacss/types\";\nimport { getSemanticTokens } from \"./semantic-tokens\";\nimport { getScales } from \"./radix-colors\";\nimport {\n  type DarkModeConfig,\n  type PresetOptions,\n  type RadixColorScales,\n} from \"./types\";\nimport { name } from \"../package.json\";\n\nconst DEFAULT_DARK_MODE_CONDITION = \".dark &\";\n\n/**\n * Represents normalized dark mode configuration.\n *\n * @internal\n */\ninterface NormalizedDarkModeConfig {\n  enabled: boolean;\n  condition?: string;\n}\n\n/**\n * Generates PandaCSS condition definitions for dark mode and P3 color gamut support.\n *\n * Conditions are CSS selectors or media queries that PandaCSS uses to create\n * conditional style modifiers (e.g., `_dark`, `_p3`).\n *\n * @param darkModeCondition Optional CSS condition for dark mode (e.g., `.dark &`).\n *                          If provided, enables the `_dark` modifier in style objects.\n * @returns An object of condition definitions for PandaCSS to extend\n *\n * @example\n * ```ts\n * // With dark mode enabled\n * getConditions(\".dark &\")\n * // => { dark: \".dark &\", p3: \"@media (color-gamut: p3)\" }\n *\n * // Without dark mode\n * getConditions()\n * // => { p3: \"@media (color-gamut: p3)\" }\n * ```\n *\n * @internal\n */\nfunction getConditions(darkModeCondition?: string): Conditions {\n  const conditions: Conditions = {};\n\n  // Add dark mode condition if provided\n  if (darkModeCondition) {\n    conditions[\"dark\"] = darkModeCondition;\n  }\n\n  // Always add P3 color gamut condition for wide color support\n  conditions[\"p3\"] = \"@media (color-gamut: p3)\";\n\n  return conditions;\n}\n\n/**\n * Normalizes dark mode configuration into a consistent format.\n *\n * Handles the following input formats:\n * - `false` or `undefined` → disabled\n * - `true` → enabled with default condition\n * - `{ condition: \"...\" }` → enabled with custom condition\n * - `{ condition: \"...\", enabled: false }` → disabled (takes precedence)\n *\n * @param darkModeOption The dark mode option from PresetOptions\n * @returns Normalized dark mode configuration\n *\n * @internal\n */\nfunction normalizeDarkMode(\n  darkModeOption?: boolean | DarkModeConfig,\n): NormalizedDarkModeConfig {\n  // Not provided or false → disabled\n  if (!darkModeOption) {\n    return { enabled: false };\n  }\n\n  // Simple boolean true → enabled with default condition\n  if (typeof darkModeOption === \"boolean\") {\n    return { enabled: true, condition: DEFAULT_DARK_MODE_CONDITION };\n  }\n\n  // Object configuration → use provided settings\n  const enabled = darkModeOption.enabled ?? true;\n  return {\n    enabled,\n    condition: darkModeOption.condition,\n  };\n}\n\n/**\n * Validates the colorScales option to ensure at least some scales will be matched.\n *\n * This is a soft validation that warns if provided color scale paths don't match\n * any actual color scales. It allows path prefixes at any level (e.g., \"amber\",\n * \"amber.dark\", \"amber.dark.p3\") and checks if they would match any available scales.\n *\n * @param colorScales The color scale paths to validate\n *\n * @internal\n */\nfunction validateColorScales(colorScales?: RadixColorScales): void {\n  if (!colorScales || colorScales.length === 0) {\n    return;\n  }\n\n  // Get all actual scale paths from the radix colors\n  const scales = getScales();\n\n  // Check each provided colorScale to see if it would match any actual scales\n  const unmatchedScales = colorScales.filter((colorScale) => {\n    // A colorScale matches if:\n    // 1. It exactly matches a scale path, OR\n    // 2. It's a prefix of any scale path (with dot boundary)\n    const isValidPrefix = scales.some(\n      (scale) =>\n        scale.path === colorScale || scale.path.startsWith(colorScale + \".\"),\n    );\n    return !isValidPrefix;\n  });\n\n  if (unmatchedScales.length > 0) {\n    console.warn(\n      `[pandacss-preset-radix-colors] Color scale paths don't match any available scales: ${unmatchedScales.join(\", \")}. ` +\n        `Valid examples: \"amber\", \"blue.dark\", \"gray.p3\", \"red.dark.a\". ` +\n        `Available base colors: ${Array.from(new Set(scales.map((s) => s.name))).join(\", \")}.`,\n    );\n  }\n}\n\n/**\n * Creates a PandaCSS preset with Radix Colors integration.\n *\n * This preset brings all Radix UI colors into PandaCSS with support for:\n * - Dark mode with automatic light/dark variants\n * - DCI-P3 wide color gamut support\n * - Filtered color scales to reduce bundle size\n * - Customizable dark mode conditions\n *\n * @param options Configuration options for the preset\n * @returns A PandaCSS preset definition\n *\n * @example\n * ```ts\n * import { defineConfig } from \"@pandacss/dev\";\n * import radixColorsPreset from \"pandacss-preset-radix-colors\";\n *\n * export default defineConfig({\n *   presets: [\n *     radixColorsPreset({\n *       darkMode: true,\n *       autoP3: true,\n *       colorScales: [\"gray\", \"blue\", \"red\"],\n *     }),\n *     \"@pandacss/preset-panda\",\n *   ],\n * });\n * ```\n */\nexport function createPreset(options?: PresetOptions): Preset {\n  // Normalize and validate options\n  const darkModeConfig = normalizeDarkMode(options?.darkMode);\n  validateColorScales(options?.colorScales);\n\n  return definePreset({\n    name,\n    conditions: {\n      extend: getConditions(\n        darkModeConfig.enabled ? darkModeConfig.condition : undefined,\n      ),\n    },\n    theme: {\n      extend: {\n        semanticTokens: {\n          colors: getSemanticTokens(\n            darkModeConfig.enabled,\n            options?.autoP3,\n            options?.colorScales,\n          ),\n        },\n      },\n    },\n  });\n}\n",
    "import * as colors from \"@radix-ui/colors\";\n\n/**\n * Reserved tag names that should not be split during color scale parsing.\n * These tags are treated as atomic units in color scale names.\n *\n * @internal\n */\nconst SCALE_RESERVED_TAGS = [\"P3\"];\n\n/**\n * Regular expression for splitting color scale full names into individual tags.\n * Splits on uppercase letters, numbers, and reserved tags (like P3).\n *\n * @internal\n */\nconst SCALE_TAGS_REGEX = new RegExp(\n  `(${SCALE_RESERVED_TAGS.join(\"|\")})|(?=[A-Z0-9])`,\n  \"g\",\n);\n\n/**\n * Represents a parsed Radix color scale with its metadata and color values.\n *\n * @example\n * A scale for \"amberdarkp3a1\" would be:\n * ```ts\n * {\n *   fullName: \"amberdarkp3a1\",\n *   tags: [\"amber\", \"dark\", \"p3\", \"a\"],\n *   name: \"amber\",\n *   path: \"amber.dark.p3.a\",\n *   dark: true,\n *   alpha: true,\n *   p3: true,\n *   shades: { 1: \"#...\", 2: \"#...\", ..., 12: \"#...\" }\n * }\n * ```\n */\nexport type Scale = {\n  /** The original full color scale name from @radix-ui/colors */\n  fullName: string;\n\n  /** Array of parsed tags from the full name */\n  tags: string[];\n\n  /** The base color name (first tag) */\n  name: string;\n\n  /** Dot-notation path built from tags (used for token references) */\n  path: string;\n\n  /** Whether this is a dark mode variant */\n  dark: boolean;\n\n  /** Whether this is an alpha (transparency) variant */\n  alpha: boolean;\n\n  /** Whether this is a DCI-P3 color gamut variant */\n  p3: boolean;\n\n  /** All 12 color shades for this scale mapped by index (1-12) */\n  shades: {\n    1: string;\n    2: string;\n    3: string;\n    4: string;\n    5: string;\n    6: string;\n    7: string;\n    8: string;\n    9: string;\n    10: string;\n    11: string;\n    12: string;\n  };\n};\n\n/**\n * Extracts tags from a Radix color scale full name.\n *\n * Splits the name on uppercase letters and numbers, respecting reserved tags like \"P3\".\n * Converts all tags to lowercase for consistent token naming.\n *\n * @example\n * ```ts\n * getScaleTags(\"amberdarkp3a\") // => [\"amber\", \"dark\", \"p3\", \"a\"]\n * getScaleTags(\"slateA\") // => [\"slate\", \"a\"]\n * getScaleTags(\"blue\") // => [\"blue\"]\n * ```\n *\n * @internal\n */\nexport function getScaleTags(fullName: string): string[] {\n  return fullName\n    .split(SCALE_TAGS_REGEX)\n    .filter(Boolean)\n    .map((x) => x.toLowerCase());\n}\n\n/**\n * Builds a dot-notation path from scale tags.\n *\n * @example\n * ```ts\n * getScalePath([\"amber\", \"dark\", \"p3\", \"a\"]) // => \"amber.dark.p3.a\"\n * getScalePath([\"blue\"]) // => \"blue\"\n * ```\n *\n * @internal\n */\nexport function getScalePath(tags: string[]): string {\n  return tags.join(\".\");\n}\n\n/**\n * Checks if a scale is an alpha (transparency) variant.\n *\n * @internal\n */\nexport function isScaleAlpha(tags: string[]): boolean {\n  return tags.includes(\"a\");\n}\n\n/**\n * Checks if a scale is a dark mode variant.\n *\n * @internal\n */\nexport function isScaleDark(tags: string[]): boolean {\n  return tags.includes(\"dark\");\n}\n\n/**\n * Checks if a scale is a DCI-P3 color gamut variant.\n *\n * @internal\n */\nexport function isScaleP3(tags: string[]): boolean {\n  return tags.includes(\"p3\");\n}\n\n/**\n * Gets the base color name from scale tags (always the first tag).\n *\n * @internal\n */\nexport function getScaleName(tags: string[]): string {\n  return tags[0];\n}\n\n/**\n * Extracts the 12 color shades from a Radix color scale object.\n *\n * Maps the color values to their shade indices (1-12), which correspond to\n * the brightness/saturation levels defined by Radix UI.\n *\n * @example\n * ```ts\n * getScaleShades({\n *   0: \"#fef3c7\",\n *   1: \"#fef3c7\",\n *   2: \"#fde68a\",\n *   // ... more shades\n * })\n * // => { 1: \"#fef3c7\", 2: \"#fdef68a\", ..., 12: \"#78350f\" }\n * ```\n *\n * @internal\n */\nexport function getScaleShades(value: any): Scale[\"shades\"] {\n  return Object.assign(\n    {},\n    ...Object.values(value).map((shade, i) => ({\n      [++i]: shade,\n    })),\n  ) as Scale[\"shades\"];\n}\n\n/**\n * Retrieves and parses all available Radix color scales.\n *\n * Each imported color from @radix-ui/colors is parsed into a Scale object\n * containing metadata and all 12 color shades.\n *\n * @param lightPrefix If true, adds a \"light\" tag to non-dark scales.\n *                    Used internally when dark mode is enabled to create\n *                    light variant tokens.\n * @returns An array of all parsed color scales\n *\n * @example\n * ```ts\n * // Get all scales without light prefix\n * const scales = getScales();\n *\n * // Get all scales with light prefix (for dark mode)\n * const scales = getScales(true);\n * ```\n *\n * @internal\n */\nexport function getScales(lightPrefix?: boolean): Scale[] {\n  return Object.entries(colors).map(([fullName, value]) => {\n    const tags = getScaleTags(fullName);\n    const dark = isScaleDark(tags);\n\n    // If the scale isn't dark, add \"light\" tag at position 1 for proper nesting\n    if (!dark && lightPrefix) tags.splice(1, 0, \"light\");\n\n    return {\n      fullName,\n      tags,\n      name: getScaleName(tags),\n      path: getScalePath(tags),\n      dark,\n      alpha: isScaleAlpha(tags),\n      p3: isScaleP3(tags),\n      shades: getScaleShades(value),\n    };\n  });\n}\n",
    "/**\n * Recursively converts an array of keys into a deeply nested object with the provided value.\n *\n * The value is placed at the deepest level, with each key creating a new nested level.\n * Used to convert flat tag arrays into nested token structures.\n *\n * @param keys Array of keys to create nesting levels with\n * @param value The value to place at the deepest level\n * @returns A nested object structure\n *\n * @example\n * ```ts\n * keysToObj([\"blue\", \"dark\", \"1\"], { value: \"#0000ff\" })\n * // => { blue: { dark: { 1: { value: \"#0000ff\" } } } }\n *\n * keysToObj([\"gray\"], { value: \"#666666\" })\n * // => { gray: { value: \"#666666\" } }\n *\n * keysToObj([], { value: \"#ffffff\" })\n * // => { value: \"#ffffff\" }\n * ```\n *\n * @internal\n */\nexport function keysToObj(keys: string[], value: any): any {\n  if (keys.length === 0) return value;\n\n  const key = keys[0];\n  const obj: any = keysToObj(keys.slice(1), value);\n\n  return { [key]: obj };\n}\n\n/**\n * Type guard to check if a value is a plain object (not null, undefined, array, or primitive).\n *\n * Used for safe recursive object merging to avoid treating arrays and functions as objects.\n *\n * @param value The value to check\n * @returns True if value is a plain object, false otherwise\n *\n * @example\n * ```ts\n * isObject({}) // => true\n * isObject(null) // => false\n * isObject([]) // => false\n * isObject(\"string\") // => false\n * ```\n *\n * @internal\n */\nexport function isObject(value: any): boolean {\n  return (\n    value !== null &&\n    value !== undefined &&\n    typeof value === \"object\" &&\n    !Array.isArray(value)\n  );\n}\n\n/**\n * Recursively merges multiple source objects into a target object.\n *\n * Nested objects are deeply merged, while primitive values are overridden.\n * This is essential for combining token definitions from multiple color scales\n * into a single semantic token structure.\n *\n * @param target The target object to merge into\n * @param sources Variable number of source objects to merge from\n * @returns The merged target object\n *\n * @example\n * ```ts\n * mergeObjs(\n *   { blue: { 1: { value: \"#0000ff\" } } },\n *   { blue: { 2: { value: \"#0000cc\" } } },\n *   { red: { 1: { value: \"#ff0000\" } } }\n * )\n * // => {\n * //   blue: {\n * //     1: { value: \"#0000ff\" },\n * //     2: { value: \"#0000cc\" }\n * //   },\n * //   red: { 1: { value: \"#ff0000\" } }\n * // }\n * ```\n *\n * @internal\n */\nexport function mergeObjs(target: any, ...sources: any[]): any {\n  if (!sources.length) return target;\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, { [key]: {} });\n\n        mergeObjs(target[key], source[key]);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n      }\n    }\n  }\n\n  return mergeObjs(target, ...sources);\n}\n",
    "import { type Scale, getScales } from \"./radix-colors\";\nimport { type RadixColorScales } from \"./types\";\nimport { keysToObj, mergeObjs } from \"./utils\";\n\n/**\n * Represents the related scales for building a token value.\n * Used internally to find dark, P3, and light scale variants.\n */\ninterface RelatedScales {\n  current: Scale;\n  light?: Scale;\n  dark?: Scale;\n  p3?: Scale;\n}\n\n/**\n * Finds the dark scale variant for a given base scale.\n * The dark scale must have the same name, alpha, and p3 settings as the base scale.\n *\n * @param scale The base scale to find the dark variant for\n * @param scales All available scales\n * @returns The dark scale if found, undefined otherwise\n *\n * @internal\n */\nexport function findDarkScale(\n  scale: Scale,\n  scales: Scale[],\n): Scale | undefined {\n  return scales.find(\n    (x) =>\n      x.name === scale.name &&\n      x.alpha === scale.alpha &&\n      x.p3 === scale.p3 &&\n      x.dark,\n  );\n}\n\n/**\n * Finds the P3 (DCI-P3) scale variant for a given base scale.\n * The P3 scale must have the same name, alpha, and dark settings as the base scale.\n *\n * @param scale The base scale to find the P3 variant for\n * @param scales All available scales\n * @returns The P3 scale if found, undefined otherwise\n *\n * @internal\n */\nexport function findP3Scale(scale: Scale, scales: Scale[]): Scale | undefined {\n  return scales.find(\n    (x) =>\n      x.name === scale.name &&\n      x.alpha === scale.alpha &&\n      x.dark === scale.dark &&\n      x.p3,\n  );\n}\n\n/**\n * Finds the light variant of a scale (when dark mode is enabled).\n * The light scale has a \"light\" tag and matches the name, alpha, dark, and p3 settings.\n *\n * @param scale The base scale to find the light variant for\n * @param scales All available scales\n * @returns The light scale if found, undefined otherwise\n *\n * @internal\n */\nexport function findLightScale(\n  scale: Scale,\n  scales: Scale[],\n): Scale | undefined {\n  return scales.find(\n    (x) =>\n      x.name === scale.name &&\n      x.alpha === scale.alpha &&\n      x.dark === scale.dark &&\n      x.p3 === scale.p3 &&\n      x.tags.includes(\"light\"),\n  );\n}\n\n/**\n * Finds all related scales for a given base scale.\n * Searches for dark, P3, and light variants based on the current scale properties.\n *\n * @param scale The base scale to find related variants for\n * @param scales All available scales\n * @param enableDarkMode Whether dark mode is enabled\n * @param enableAutoP3 Whether automatic P3 switching is enabled\n * @returns An object containing the current scale and any found related scales\n *\n * @internal\n */\nexport function findRelatedScales(\n  scale: Scale,\n  scales: Scale[],\n  enableDarkMode: boolean,\n  enableAutoP3: boolean,\n): RelatedScales {\n  const result: RelatedScales = { current: scale };\n\n  // Find dark scale if dark mode is enabled and this is not a dark scale\n  if (enableDarkMode && !scale.dark && !scale.tags.includes(\"light\")) {\n    result.dark = findDarkScale(scale, scales);\n  }\n\n  // Find P3 scale if autoP3 is enabled and this is not a P3 scale\n  // Only if we didn't find a dark scale (dark mode takes precedence)\n  if (!result.dark && enableAutoP3 && !scale.p3) {\n    result.p3 = findP3Scale(scale, scales);\n  }\n\n  // Find light scale if we found a dark scale\n  if (result.dark) {\n    result.light = scale.tags.includes(\"light\")\n      ? scale\n      : findLightScale(scale, scales);\n  }\n\n  return result;\n}\n\n/**\n * Builds a token value for a specific shade of a color.\n * Creates either a simple value or a conditional value structure based on available variants.\n *\n * @param shade The shade value (the actual CSS color)\n * @param shadeIndex The shade index (1-12)\n * @param relatedScales The related scales (dark, P3, light variants) for this color\n * @returns The token value (either a string or an object with conditional variants)\n *\n * @internal\n *\n * @example\n * // Simple color without variants\n * buildTokenValue(\"#0000ff\", 1, { current: blueScale }) => \"#0000ff\"\n *\n * // Color with dark mode support\n * buildTokenValue(\"#e0e6ff\", 1, { current: blueScale, dark: blueDarkScale, light: blueLightScale })\n * // => { base: \"{colors.blue.light.1}\", _dark: \"{colors.blue.dark.1}\" }\n *\n * // Color with P3 variant\n * buildTokenValue(\"#0000ff\", 1, { current: blueScale, p3: blueP3Scale })\n * // => { base: \"#0000ff\", _p3: \"{colors.blue.p3.1}\" }\n */\nexport function buildTokenValue(\n  shade: string,\n  shadeIndex: string | number,\n  relatedScales: RelatedScales,\n): any {\n  // If there's a dark scale, create conditional dark/light values\n  if (relatedScales.dark) {\n    return {\n      base: `{colors.${relatedScales.light?.path}.${shadeIndex}}`,\n      _dark: `{colors.${relatedScales.dark.path}.${shadeIndex}}`,\n    };\n  }\n\n  // If there's a P3 scale, create conditional P3 value\n  if (relatedScales.p3) {\n    return {\n      base: shade,\n      _p3: `{colors.${relatedScales.p3.path}.${shadeIndex}}`,\n    };\n  }\n\n  // No variants, return the simple shade value\n  return shade;\n}\n\n/**\n * Generates semantic tokens for all Radix colors based on configuration options.\n *\n * This function creates a nested token structure where colors are organized by their variants.\n * For example, a blue color might create tokens like:\n * - `colors.blue.1` through `colors.blue.12`\n * - `colors.blue.dark.1` through `colors.blue.dark.12` (when dark mode is enabled)\n * - `colors.blue.dark.p3.1` (when P3 variant exists)\n *\n * @param darkMode Whether dark mode support should be enabled\n * @param autoP3 Whether automatic P3 color gamut switching should be enabled\n * @param colorScales Optional array of color scale names to include. If empty or not provided, all scales are included.\n * @returns A nested object of semantic token definitions for use in PandaCSS\n *\n * @example\n * ```ts\n * // Get all color tokens with dark mode enabled\n * const tokens = getSemanticTokens(true, false, []);\n *\n * // Get only gray and blue with P3 support\n * const tokens = getSemanticTokens(false, true, [\"gray\", \"blue\"]);\n * ```\n *\n * @internal\n */\nexport function getSemanticTokens(\n  darkMode?: boolean,\n  autoP3?: boolean,\n  colorScales: RadixColorScales = [],\n): Record<string, any> {\n  // Get all available scales, including light variants if dark mode is enabled\n  let scales = getScales(darkMode);\n\n  // When dark mode is enabled, also include the light variants of base colors\n  // These are used to create the _dark conditional values\n  if (darkMode) {\n    scales = scales.concat(getScales(false).filter((x) => !x.dark));\n  }\n\n  // Filter scales by requested color scales\n  const filteredScales = scales.filter((scale) =>\n    shouldIncludeScale(scale, colorScales),\n  );\n\n  // Generate tokens for each filtered scale\n  return mergeObjs(\n    {},\n    ...filteredScales.map((scale) =>\n      generateScaleTokens(scale, filteredScales, darkMode, autoP3),\n    ),\n  );\n}\n\n/**\n * Determines whether a scale should be included based on the colorScales filter.\n *\n * If colorScales is empty or not provided, all scales are included.\n * Otherwise, only scales whose path matches or starts with one of the provided\n * colorScale paths are included. This allows filtering by any level of specificity.\n *\n * @param scale The scale to check\n * @param colorScales The list of color scale paths to include (e.g., \"amber\", \"blue.dark\", \"gray.p3\")\n * @returns True if the scale should be included, false otherwise\n *\n * @example\n * ```ts\n * // Scale with path \"amber.dark.p3\" would be included by:\n * shouldIncludeScale(scale, [\"amber\"]) // ✓ matches prefix \"amber\"\n * shouldIncludeScale(scale, [\"amber.dark\"]) // ✓ matches prefix \"amber.dark\"\n * shouldIncludeScale(scale, [\"amber.dark.p3\"]) // ✓ exact match\n * shouldIncludeScale(scale, [\"amber.dark.p3.a\"]) // ✓ exact match\n * shouldIncludeScale(scale, [\"blue\"]) // ✗ no match\n * ```\n *\n * @internal\n */\nfunction shouldIncludeScale(\n  scale: Scale,\n  colorScales: RadixColorScales,\n): boolean {\n  // If no filter is specified, include all scales\n  if (colorScales.length === 0) {\n    return true;\n  }\n\n  // Include the scale if its path matches or starts with any provided colorScale path\n  // Use startsWith with a dot check to avoid \"amber\" matching \"amberA\"\n  return colorScales.some((colorScale) => {\n    // Exact match or prefix match (with dot boundary)\n    return scale.path === colorScale || scale.path.startsWith(colorScale + \".\");\n  });\n}\n\n/**\n * Generates semantic token definitions for a single color scale.\n *\n * Creates tokens for each shade (1-12) of the color, with appropriate variants\n * (dark, P3) if applicable based on the configuration and available scales.\n *\n * @param scale The color scale to generate tokens for\n * @param allScales All available scales (used to find related variants)\n * @param enableDarkMode Whether dark mode is enabled\n * @param enableAutoP3 Whether auto P3 is enabled\n * @returns A nested object representing the token structure for this scale\n *\n * @internal\n */\nfunction generateScaleTokens(\n  scale: Scale,\n  allScales: Scale[],\n  enableDarkMode: boolean = false,\n  enableAutoP3: boolean = false,\n): Record<string, any> {\n  // Find related scale variants (dark, light, P3)\n  const relatedScales = findRelatedScales(\n    scale,\n    allScales,\n    enableDarkMode,\n    enableAutoP3,\n  );\n\n  // Generate token entries for each shade (1-12)\n  const shadeTokens = Object.entries(scale.shades).map(\n    ([shadeIndex, color]) => {\n      const tokenValue = buildTokenValue(color, shadeIndex, relatedScales);\n\n      return {\n        [shadeIndex]: {\n          value: tokenValue,\n        },\n      };\n    },\n  );\n\n  // Merge all shade tokens into a single object and convert to nested structure\n  const mergedShades = mergeObjs({}, ...shadeTokens);\n\n  return keysToObj(scale.tags, mergedShades);\n}\n",
    "import * as colors from \"@radix-ui/colors\";\n\n/**\n * Helper type to transform a color scale name to its path format.\n * Splits on \"Dark\", \"P3\", and \"A\", then joins with dots.\n */\ntype TransformScaleName<T extends string> =\n  T extends `${infer Prefix}Dark${infer Rest}`\n    ? `${Lowercase<Prefix>}.dark${TransformScaleName<Rest>}`\n    : T extends `${infer Prefix}P3${infer Rest}`\n      ? `${Lowercase<Prefix>}.p3${TransformScaleName<Rest>}`\n      : T extends `${infer Prefix}A${infer Rest}`\n        ? `${Lowercase<Prefix>}.a${TransformScaleName<Rest>}`\n        : Lowercase<T>;\n\n/**\n * Helper type to extract and transform all color scale keys.\n */\ntype ColorScaleKeys = {\n  [K in keyof typeof colors as K extends string\n    ? K extends `${string}default${string}`\n      ? never\n      : TransformScaleName<K>\n    : never]: true;\n};\n\n/**\n * Helper function to transform a scale name to path format.\n */\nfunction transformScaleName(scale: string): string {\n  return scale\n    .split(/(Dark|P3|A)/)\n    .map((x) => x.toLowerCase())\n    .filter(Boolean)\n    .join(\".\");\n}\n\n/**\n * All available Radix color scales.\n * Automatically derived from @radix-ui/colors with full type safety and autocomplete.\n */\nexport const radixColorScales = Object.keys(colors)\n  .filter((scale): scale is keyof typeof colors => !scale.includes(\"default\"))\n  .map(transformScaleName) as unknown as Array<keyof ColorScaleKeys>;\n\n/**\n * A single Radix color scale path.\n *\n * @example \"amber\", \"blue.dark\", \"gray.p3\", \"red.dark.a\"\n */\nexport type RadixColorScale = (typeof radixColorScales)[number];\n\n/**\n * An array of Radix color scale paths for filtering.\n */\nexport type RadixColorScales = RadixColorScale[];\n\n/**\n * Configuration for dark mode support.\n */\nexport interface DarkModeConfig {\n  /**\n   * The CSS condition/selector used to apply dark mode styles.\n   * This condition will be used as a modifier in your style objects (e.g., `_dark`).\n   *\n   * @example `.dark &` - Applies when an ancestor has the `.dark` class\n   * @example `[data-theme='dark'] &` - Applies when parent has `data-theme=\"dark\"`\n   * @example `@media (prefers-color-scheme: dark) &` - Applies based on system preference\n   *\n   * @default `.dark &`\n   */\n  condition: string;\n\n  /**\n   * Whether dark mode is enabled. Set to `false` to disable dark mode functionality.\n   * This allows you to easily toggle dark mode on/off programmatically.\n   *\n   * @default true\n   */\n  enabled?: boolean;\n}\n\n/**\n * Configuration options for the Radix Colors preset.\n */\nexport interface PresetOptions {\n  /**\n   * Enable dark mode support. Colors will generate both light and dark variants.\n   * When enabled, a `light` variant will be automatically added to ensure colors\n   * can be kept light even in dark mode contexts.\n   *\n   * @example\n   * ```ts\n   * // Use default dark mode condition (.dark &)\n   * darkMode: true\n   *\n   * // Use custom dark mode condition\n   * darkMode: { condition: \"[data-theme='dark'] &\" }\n   *\n   * // Disable dark mode programmatically\n   * darkMode: { condition: \".dark &\", enabled: false }\n   * ```\n   */\n  darkMode?: boolean | DarkModeConfig;\n\n  /**\n   * Automatically use DCI-P3 color variants when the user's device supports wide color gamut.\n   * This will conditionally apply the P3 color variant using the `_p3` modifier when\n   * the browser supports it via `@media (color-gamut: p3)`.\n   *\n   * When both dark mode and autoP3 are enabled, tokens will intelligently choose\n   * the appropriate variant based on both conditions.\n   *\n   * @default false\n   *\n   * @example\n   * ```ts\n   * autoP3: true  // Uses P3 variant when available\n   * ```\n   */\n  autoP3?: boolean;\n\n  /**\n   * Specify which Radix color scales to include in the preset using path-based filtering.\n   * This can be used to reduce the generated CSS size by including only the colors you need.\n   * All scales are included by default when not specified.\n   *\n   * You can filter at any level of specificity:\n   * - Base colors: \"amber\", \"blue\", \"gray\"\n   * - Dark variants: \"amber.dark\", \"blue.dark\"\n   * - Alpha variants: \"gray.a\", \"slate.dark.a\"\n   * - P3 variants: \"blue.p3\", \"red.dark.p3\"\n   * - Specific variants: \"amber.dark.p3.a\"\n   *\n   * All variants beneath your specified path will be included automatically.\n   * For example, providing \"amber.dark\" will include \"amber.dark\", \"amber.dark.a\",\n   * \"amber.dark.p3\", and \"amber.dark.p3.a\".\n   *\n   * @default [] (includes all scales)\n   *\n   * @example\n   * ```ts\n   * // Include only gray and blue colors with all their variants\n   * colorScales: [\"gray\", \"blue\"]\n   *\n   * // Include only dark variants of amber and blue\n   * colorScales: [\"amber.dark\", \"blue.dark\"]\n   *\n   * // Include only P3 colors and dark P3 colors\n   * colorScales: [\"gray.p3\", \"blue.dark.p3\"]\n   *\n   * // Mix different specificity levels\n   * colorScales: [\"gray\", \"blue.dark\", \"red.p3\"]\n   * ```\n   */\n  colorScales?: RadixColorScales;\n}\n"
  ],
  "mappings": "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",
  "debugId": "FFE2945C7D9218F364756E2164756E21",
  "names": []
}